package t4_jvm;

public class Topic1 {
    /*
        1.JVM组成
            程序计数器：线程私有，当前线程执行的字节码行号指示器

            虚拟机栈：Java线程私有，描述java方法执行的内存模型，每个方法执行的同时，都会创建一个栈帧保存相关信息。

            本地方法栈：本地方法私有，描述本地方法执行的内存模型。

            堆：一个JVM内的所有线程所共有，用于存储所有的对象实例及数组。是垃圾回收机制主要管理的区域，
               也是各种考察和使用的重中之重。

            方法区：各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

            直接内存（堆外内存）：直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，
                   但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError 异常出现。

                   直接内存的使用，避免了在Java 堆和Native 堆中来回复制数据；在一些场景中能显著提高性能。

                   直接内存的分配不会受到Java 堆大小的限制，但是，还是会受到本机总内存（包括RAM 及SWAP 区或者分页文件）的大小及处理器
                   寻址空间的限制。服务器管理员配置虚拟机参数时，一般会根据实际内存设置-Xmx等参数信息，但经常会忽略掉直接内存，
                   使得各个内存区域的总和大于物理内存限制（包括物理上的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。

                   一般的应用开发用的少。

        2.对象的垃圾回收（GC）规则
            引用计数法：通过引用计数来判断一个对象是否可以被回收。

                      简单高效，但无法解决循环引用问题。

            可达性分析法：通过一系列的GC Roots的对象作为起始点，从这些根节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），
                        当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。
                GC Roots：
                    1.虚拟机栈中引用的对象
                    2.本地方法栈中的对象
                    3.方法区中类静态属性引用的对象
                    4.方法区中的常量对象


        3.垃圾回收算法与垃圾收集器
            垃圾回收算法：
                1.标记清除算法
                    容易造成空间碎片，以至于频繁触发垃圾回收；

                2.标记整理算法
                    标记后，还要进行整理，效率更低；但不会造成空间上的碎片；

                3.复制算法
                    在对象存活率较低的情况下效率高，且不会有碎片，但是浪费存储空间；

                4.分代收集算法
                    根据对象生存周期的长短，对对象进行分代，JVM中将对象分为"年轻代"和"老年代"；
                    年轻代采用"复制算法"，
                    老年代采用"标记清除算法"或者"标记整理算法"

            Java堆的组成
                年轻代（8:1:1）：
                    特点：朝生夕死，生命极短。
                    Eden区：
                    From Survivor区：
                    To Survivor区：

                老年代：
                    1.长期存活的对象进入老年代
                    2.大对象直接进入老年代

            垃圾回收器：
                注意的问题：
                    1.垃圾回收是否是多线程并行处理
                    2.垃圾回收线程和用户线程是否可以并发进行  ————> Stop the world问题，造成系统的延迟卡顿
                （并行：同时进行；并发：交替执行，不一定并行）
                    3.管理的区域，采用的垃圾回收算法

                Serial收集器：
                    年轻代，单线程，Stop the world，复制算法，Client模式下年轻代默认垃圾回收器

                ParNew收集器：
                    年轻代，多线程，Stop the world，复制算法，Server模式下年轻代默认垃圾回收器
                    Serial收集器的多线程版本

                Parallel Scavenge收集器（吞吐量优先收集器）：
                    年轻代，多线程，Stop the world，复制算法，
                    设置参数，动态调节，以获得更高的吞吐量。（其它垃圾回收器关注缩短垃圾回收时间）
                    吞吐量=程序运行时间/（程序运行时间+垃圾回收时间）
                    不能与CMS共用（https://www.zhihu.com/question/43492129   框架不兼容）

                Serial Old收集器：
                    老年代，单线程，Stop the world，标记-整理算法，Client模式下老年代默认垃圾回收器
                    CMS收集器发生CMF后使用的老年代回收器

                Parallel Old收集器：
                    老年代，多线程，Stop the world，标记-整理算法，Parallel Scavenge的老年代版本
                    https://blog.csdn.net/qq_33915826/article/details/79672772（各种垃圾回收器的组合）

                CMS收集器（Concurrent Mark Sweep）：
                    老年代，多线程，Stop the world，Server模式下老年代默认垃圾回收器
                    以获得最短停顿时间为目标。
                    其垃圾回收过程相对较复杂，分为四个步骤：
                        （1）初始标记（Stop the world）

                        （2）并发标记

                        （3）重新标记（Stop the world）

                        （4）并发清除

                    CMF（Concurrent Mode Failure）

                G1收集器（Garbage First）：


        4.引用

        5.常见问题及排查工具

        6.性能调优

        7.类加载机制
            new 一个对象的过程
                https://www.cnblogs.com/JackPn/p/9386182.html

        8.java内存模型

        9.逃逸分析

        10.ThreadLocal
     */
}
