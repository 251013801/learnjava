package t8_distributed_system;

public class Topic1 {
    /*
        1.Redis
            （1）单线程，"内存"存储数据，

            （2）用途：缓存，递增序号生成器，分布式锁

            （3）数据类型
                （1）string
                （2）hash
                （3）list
                （4）set
                （5）zset：有序的set

            （4）编码
                redis中每种数据类型有不同的编码方式，redis会根据情况选择合适的编码方式；（CPU资源和存储资源之间的权衡）

            （5）纯内存存储，IO多路复用技术、非阻塞IO，单线程架构造就Redis高性能
            （6）持久化（断电了、宕机了，数据还是能够恢复）
                RDB（Redis DataBase）、AOF（Append-Only File）
                RDB：
                    fork一个新的子进程，把当前数据生成快照，保存到硬盘中
                    优点：
                        a.RDB文件是压缩的二进制文件，保存了某个时间点的Redis数据快照，适用于备份、全量复制场景；
                        b.数据恢复速度远快于AOF方式。
                    缺点：
                        a.没法做到实时持久化、秒级持久化(频繁fork进程，执行成本过高)

                AOF：
                    将执行的每一条命令以文本形式记录在单独的文件中，（类似于Mysql的binlog）
                    与RDB不同的是，AOF是增量的形式。
                    优点：
                         a.有不同的sync策略，不需要fork进程，执行成本低，可以做到实时持久化；
                    缺点：
                         a.持久化文件较大
                         b.和redis写使用同一进程，对性能有一定影响

                当对数据完整性要求不高时（可以容忍几分钟的数据损失），可以只采用RDB持久化策略；
                当对数据完整性要求高的时候，需要开启AOF存储，syn策略一般为每秒写盘一次。

            （7）高可用（可提供服务的时间比例高）
                主从结构
                    主Redis —— 从Redis
                    一主一从，一主多从、树状主从结构
                    一般主节点提供写服务，从节点提供读服务（也使读的性能得到了提高）

                主节点发生故障，需要从节点承担主节点职能，这时需要人工手动介入配置
                （更改应用方主节点IP，晋升从节点为主节点，配置其它从节点从新的主节点复制数据）；
                  |
                  |
                哨兵机制：
                    如图（了解即可）

            （8）高性能（主备、集群、一致性hash算法、虚拟节点）
                主从结构中，主写，从读可以提高redis服务的读性能，但是写性能依旧是瓶颈；
                可以通过"集群"的方式来解决redis服务的"写性能"瓶颈
                Redis集群分区的实现：
                    一致性hash算法
                    普通的hash算法，即取余法，当某一节点失效时，所有节点都需要变动。

                    而一致性hash算法中，key取余后分配到对应的节点，而所有节点按顺序组成一个环，
                    当某一节点失效后，该节点的所有数据移动到临近的一个节点上，而不进行全量的重新计算和移动

                    一致性hash算法的问题：数据倾斜问题（某一节点失效后，导致临近的节点数据量过大）；
                      |
                    解决方法：虚拟节点法，例如：设置100个虚拟节点，key按取余法映射到虚拟节点上，
                            再将虚拟节点平均分配到物理节点上，当某一物理节点失效后，将其承载的虚拟节点
                            平均分配到其它物理节点上，避免数据倾斜。

            （9）Jedis
                我们可以通过命令行，使用命令操作redis
                在程序中，会依赖相应的组件库，java中就是Jedis，有些公司会在jedis的基础上进行封装

            （10）常见面试题：
                （1）redis和memcached的比较：
                    1、Redis和Memcache都是将数据存放在内存中，都是内存数据库。
                    2、Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储；
                    3、虚拟内存--Redis当物理内存用完时，可以将一些很久没用到的value 交换到磁盘；
                    4、redis是单线程的，memcached是多线程的；
                       当单机redis实例数目等于处理器核数时，redis性能会好些，避免了进程间的通信、同步
                    5、redis支持RDB、AOF两种持久化机制，memcached不支持持久化；
                    6、灾难恢复--memcache挂掉后，数据不可恢复; redis数据丢失后可以通过aof恢复；
                    7、Redis支持数据的备份，即master-slave模式的数据备份；
                    8、应用场景不一样：Redis出来作为NoSQL数据库使用外，还能用做分布式锁、消息队列、数据堆栈和数据缓存等；
                       Memcached适合于缓存SQL语句、数据集、用户临时性数据、延迟查询数据和session等。

                （2）redis如何实现分布式锁？
                    set key value PX 100 NX  （一条命令设置key，过期时间，不存在才能设置）
                    key是我们锁的关键词
                    考虑这样一个场景：
                        对一个订单进行一系列操作，需要保证在同一时刻一个订单，只能同一服务的多个实例中只有一个实例处理，
                        此时，需要使用分布式锁，并且采用订单号拼装key。
                    http://doc.redisfans.com/string/set.html

                （3）你知道的redis的命令（https://www.cnblogs.com/kevinws/p/6281395.html）
                    keys：生产环境不能使用
                    get key
                    set key value
                    del key
                    setnx key value：设置，当且仅当key不存在
                    incr key
                    等等
                    使用请查表：http://doc.redisfans.com

                （4）redis支持哪些数据类型？

                （5）RDB和AOF的区别？

                （6）什么是一致性哈希算法？什么是哈希槽(虚拟节点)？


                （7）使用过Redis做消息队列么，你是怎么用的？
                    一般使用list结构作为队列
                    1. rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。
                    2. rpush生产消息，blpop消费消息，阻塞消费，不需要sleep

                    多个消费者消费，怎么实现？有什么缺点？
                        使用redis的pub/sub（发布订阅）功能，
                        缺点是当消费者下线时，这中间产生的消息会丢失，即没有消息堆积的能力；
                        另外，redis作为消息队列，性能和易用性也不如专业的消息队列。

        2.MQ（message queue）
            RocketMQ、Kafka、RabbitMQ等
            MQ并不神秘，

            作用：
                1. 解耦
                2. 流量削峰（削峰填谷）
                3. 消息分发

            常见的MQ：
                RabbitMQ
                RocketMQ
                Kafka

            MQ中常见概念（以RocketMQ为例）：
              组成：
                1. Nameserver
                2. Broker（Master/Slave）
                3. Producer
                4. Consumer
              使用：
                1. Topic
                2. tag
                用来对消息进行分类，topic标志应用，tag标志消息类型

              常见问题：
                1. 消息重复，幂等处理

                消息可靠性、mq可用性、消息积压等问题

        3.秒杀问题
            秒杀，它是一个高并发的问题，大家可以通过秒杀看看高并发问题一般是怎么处理的。
            （1）多个无状态服务实例，做复杂均衡

            （2）削峰
                消息队列
                减少秒杀请求时间，解耦秒杀请求服务和秒杀处理服务，同时超过数目的请求直接丢弃不处理

            （3）减库存
                redis
                redis单线程机制保证商品不会超卖，同时redis的高性能减少了请求处理时间。
                避免mysql并发瓶颈。

            （4）展示
                轮训获取，前端异步获取结果

        4.缓存
            缓存可以分为本地缓存，缓存服务（分布式缓存）。
            现在，大多数互联网公司使用redis作为缓存。

            分布式缓存存在的一些问题：
                1.缓存雪崩
                    大量缓存同时过期，导致缓存同时更新，给数据库服务器带来巨大压力。

                2.缓存穿透
                    大量查找不存在的key，导致大量对数据库的访问，使数据库宕机。

                3.数据库更新时的缓存问题

                4.可用性问题

                5.容量问题、并发问题

        5.共享Session问题

        6.分布式锁
            分布式场景下，为了数据多个实例正确处理，我们需要使用分布式锁。

            数据库乐观锁实现：
            redis实现分布式锁：
                https://www.cnblogs.com/linjiqin/p/8003838.html
            zookeeper实现分布式锁

            思考题：利用Redis实现一个"可重入"，"可自旋等待"的分布式锁


     */
}
